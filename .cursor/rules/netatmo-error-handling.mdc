---
globs: *.ts,*.tsx
description: Netatmo API error handling and rate limiting
---

# Netatmo API Error Handling Rules

## Error Types and Handling
```typescript
interface NetatmoApiError {
  error: {
    code: number;
    message: string;
  };
}

// Common Netatmo API error codes
const NETATMO_ERROR_CODES = {
  INVALID_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  RATE_LIMITED: 429,
  INTERNAL_ERROR: 500,
  SERVICE_UNAVAILABLE: 503
} as const;

// Error handling wrapper
const handleNetatmoApiError = (error: any): string => {
  if (error.response?.data?.error) {
    const { code, message } = error.response.data.error;
    
    switch (code) {
      case NETATMO_ERROR_CODES.UNAUTHORIZED:
        return 'Authentifizierung fehlgeschlagen. Bitte melde dich erneut an.';
      case NETATMO_ERROR_CODES.RATE_LIMITED:
        return 'Zu viele Anfragen. Bitte warte einen Moment.';
      case NETATMO_ERROR_CODES.SERVICE_UNAVAILABLE:
        return 'Netatmo Service ist derzeit nicht verfügbar.';
      default:
        return message || 'Ein unbekannter Fehler ist aufgetreten.';
    }
  }
  
  return 'Netzwerkfehler. Bitte überprüfe deine Internetverbindung.';
};
```

## Rate Limiting Implementation
```typescript
// Rate limiting configuration
const RATE_LIMIT_CONFIG = {
  maxRequests: 100,
  windowMs: 15 * 60 * 1000, // 15 minutes
  retryAfter: 60 * 1000 // 1 minute
};

// Rate limiter implementation
class NetatmoRateLimiter {
  private requests: number[] = [];
  
  canMakeRequest(): boolean {
    const now = Date.now();
    const windowStart = now - RATE_LIMIT_CONFIG.windowMs;
    
    // Remove old requests outside the window
    this.requests = this.requests.filter(time => time > windowStart);
    
    return this.requests.length < RATE_LIMIT_CONFIG.maxRequests;
  }
  
  recordRequest(): void {
    this.requests.push(Date.now());
  }
  
  getRetryAfter(): number {
    if (this.requests.length === 0) return 0;
    
    const oldestRequest = Math.min(...this.requests);
    const windowEnd = oldestRequest + RATE_LIMIT_CONFIG.windowMs;
    return Math.max(0, windowEnd - Date.now());
  }
}

const rateLimiter = new NetatmoRateLimiter();
```

## Retry Logic with Exponential Backoff
```typescript
// Retry configuration
const RETRY_CONFIG = {
  maxRetries: 3,
  baseDelay: 1000, // 1 second
  maxDelay: 30000, // 30 seconds
  backoffMultiplier: 2
};

const retryWithBackoff = async <T>(
  fn: () => Promise<T>,
  retries = RETRY_CONFIG.maxRetries
): Promise<T> => {
  try {
    return await fn();
  } catch (error) {
    if (retries === 0) throw error;
    
    // Check if error is retryable
    if (isRetryableError(error)) {
      const delay = Math.min(
        RETRY_CONFIG.baseDelay * Math.pow(RETRY_CONFIG.backoffMultiplier, RETRY_CONFIG.maxRetries - retries),
        RETRY_CONFIG.maxDelay
      );
      
      await new Promise(resolve => setTimeout(resolve, delay));
      return retryWithBackoff(fn, retries - 1);
    }
    
    throw error;
  }
};

const isRetryableError = (error: any): boolean => {
  const status = error.response?.status;
  return status === 429 || status === 503 || status >= 500;
};
```

## API Request Wrapper
```typescript
const makeNetatmoRequest = async <T>(
  url: string,
  options: RequestInit = {},
  accessToken: string
): Promise<T> => {
  // Check rate limit
  if (!rateLimiter.canMakeRequest()) {
    const retryAfter = rateLimiter.getRetryAfter();
    throw new Error(`Rate limit exceeded. Retry after ${retryAfter}ms`);
  }
  
  // Record request
  rateLimiter.recordRequest();
  
  // Make request with retry logic
  return retryWithBackoff(async () => {
    const response = await fetch(url, {
      ...options,
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
        ...options.headers
      }
    });
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      const error = new Error(handleNetatmoApiError({ response: { data: errorData } }));
      (error as any).status = response.status;
      throw error;
    }
    
    return response.json();
  });
};
```

## Error Boundary Component
```typescript
interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  retryCount: number;
}

class NetatmoErrorBoundary extends React.Component<
  React.PropsWithChildren<{}>,
  ErrorBoundaryState
> {
  constructor(props: React.PropsWithChildren<{}>) {
    super(props);
    this.state = { hasError: false, error: null, retryCount: 0 };
  }
  
  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error, retryCount: 0 };
  }
  
  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Netatmo API Error:', error, errorInfo);
    // Log to error tracking service
  }
  
  handleRetry = () => {
    this.setState(prevState => ({
      hasError: false,
      error: null,
      retryCount: prevState.retryCount + 1
    }));
  };
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Netatmo Verbindungsfehler</h2>
          <p>{this.state.error?.message}</p>
          <button onClick={this.handleRetry}>
            Erneut versuchen
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}
```